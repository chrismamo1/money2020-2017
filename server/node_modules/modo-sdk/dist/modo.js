"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
const https = require("https");
const P = require("pino");
const auth_1 = require("./auth");
const logger = P();
const keepalive = require("agentkeepalive");
const qs = require("qs");
const DATE_HEADER = "X-Modo-Date";
const AUTH_HEADER = "Authorization";
class Modo {
    constructor(location, credentials, useKeepAliveAgent = false) {
        if (useKeepAliveAgent) {
            this.Agent = new keepalive.HttpsAgent({
                maxSockets: 100,
                timeout: 60000,
            });
        }
        else {
            this.Agent = https.globalAgent;
        }
        this.location = location;
        this.credentials = credentials;
    }
    vaultEncrypt(data, vaultType = "BLOB_DATA", credentials = this.credentials) {
        return this._getKey(vaultType, credentials).then((key) => {
            return crypto.publicEncrypt({ key }, data);
        });
    }
    openCard(pan, exp_month, exp_year, zip, cvv, credentials = this.credentials) {
        return this.getKey("OPEN_CARD", credentials).then((key) => {
            return this.query('/vault/add', {
                'vault_type': 'OPEN_CARD',
                'description': 'vault/add a json_to_be_encrypted credit card',
                'json_to_be_encrypted': JSON.stringify({
                    'pan': pan,
                    'exp_month': exp_month,
                    'exp_year': exp_year,
                    'zip': zip,
                    'cvv': cvv
                })
            }, null, credentials);
        };
    }
    query(endpoint, params = {}, locationOverride, credentials = this.credentials, authType = "MODO1", json = true) {
        if (credentials == null) {
            return Promise.reject("No valid credentials provided");
        }
        let body;
        const location = (locationOverride != null) ? locationOverride : this.location;
        const uri = location.base + endpoint;
        const headers = {};
        if (json) {
            body = JSON.stringify(params);
        }
        else {
            body = (params) ? qs.stringify(params, { encodeValuesOnly: true }) : "";
        }
        const hostname = location.api_url;
        const agent = this.Agent;
        const sig = auth_1.ModoSignatures[authType](uri, body, credentials);
        headers[DATE_HEADER] = sig.timestamp;
        headers[AUTH_HEADER] = sig.signature;
        headers["Content-Type"] = (json) ? "application/json" : "application/x-www-form-urlencoded";
        return new Promise((resolve, reject) => {
            "use strict";
            let responseBody = "";
            const req = https.request({
                agent,
                headers,
                hostname,
                method: "POST",
                path: uri,
                port: 443,
            }, (res) => {
                "use strict";
                res.setEncoding("utf8");
                res.on("data", (chunk) => {
                    responseBody += chunk;
                });
                res.on("end", () => {
                    const responseData = JSON.parse(responseBody);
                    logger.info({ callRef: responseData.call_reference, endpoint });
                    if (res.statusCode === 401) {
                        logger.error(res, "Request Auth Failure");
                        resolve(responseData);
                    }
                    else if (res.statusCode >= 300) {
                        resolve(responseData);
                    }
                    else {
                        resolve(responseData);
                    }
                });
            });
            req.on("end", (err) => {
                "use strict";
                logger.error(err, "Modo request died");
                resolve(err);
            });
            req.on("error", (err) => {
                logger.error(err, "Modo request died");
                reject(err);
            });
            req.write(body, "utf8");
            req.end();
        });
    }
    _getKey(vaultType = "BLOB_DATA", credentials = this.credentials) {
        if ((this.vaultEncKeyProm != null) && (this.vaultEncKeyProm[vaultType] != null)) {
            return this.vaultEncKeyProm[vaultType];
        }
        if ((this.vaultEncKey == null) || (this.vaultEncKey[vaultType] == null)) {
            let vaultEncKey[vaultType] = this.vaultEncKey[vaultType];
            // FIXME: find out if this should care about more than just BLOB_DATA key
            this.vaultEncKeyProm[vaultType] = (this.query("/vault/get_encryption_key", {
                MODO_AUTH: credentials.key,
                type: vaultType,
            }, null, credentials)).then((response) => {
                vaultEncKey = response.response_data.encryption_key;
                return vaultEncKey;
            }, (err) => {
                logger.error("Failed to acquire vault encryption key for type " + vaultType);
                throw new Error("Failed to acquire vault key for type " + vaultType);
            });
            return this.vaultEncKeyProm[vaultType];
        }
        else {
            return Promise.resolve(this.vaultEncKey[vaultType]);
        }
    }
}
exports.Modo = Modo;
//# sourceMappingURL=modo.js.map
